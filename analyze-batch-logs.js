#!/usr/bin/env node

/**
 * Batch Log Analysis Tool
 * 
 * This script helps analyze the detailed logs generated by the enhanced orchestrator mode.
 * It can provide insights into failures, performance bottlenecks, and troubleshooting information.
 */

import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';

const RESULTS_DIR = './automation-results';

async function findBatchDirs() {
    const detailedLogsDir = path.join(RESULTS_DIR, 'detailed-logs');
    if (!await fs.pathExists(detailedLogsDir)) {
        console.log(chalk.red('No detailed logs directory found. Run a batch operation first.'));
        return [];
    }
    
    const dirs = await fs.readdir(detailedLogsDir);
    return dirs.filter(async (dir) => {
        const dirPath = path.join(detailedLogsDir, dir);
        return (await fs.stat(dirPath)).isDirectory();
    });
}

async function analyzeBatch(batchId) {
    const batchDir = path.join(RESULTS_DIR, 'detailed-logs', batchId);
    
    if (!await fs.pathExists(batchDir)) {
        console.log(chalk.red(`Batch ${batchId} not found.`));
        return;
    }
    
    console.log(chalk.blue(`\n📊 Analyzing batch: ${batchId}`));
    console.log('='.repeat(60));
    
    // Read batch summary
    const summaryFile = path.join(batchDir, 'batch-summary.log');
    if (await fs.pathExists(summaryFile)) {
        console.log(chalk.green('\n📋 Batch Summary:'));
        const summary = await fs.readFile(summaryFile, 'utf8');
        console.log(chalk.dim(summary.split('\n').slice(0, 10).join('\n')));
    }
    
    // Find all run log files
    const files = await fs.readdir(batchDir);
    const runIds = new Set();
    const logTypes = new Set();
    
    files.forEach(file => {
        if (file.endsWith('.log') && file !== 'batch-summary.log') {
            const [runId, logType] = file.replace('.log', '').split('-').slice(0, -1).join('-').split('-');
            if (runId && logType) {
                runIds.add(runId);
                logTypes.add(logType);
            }
        }
    });
    
    console.log(chalk.green(`\n🏃 Found ${runIds.size} runs with log types: ${Array.from(logTypes).join(', ')}`));
    
    // Analyze failures
    const failedRuns = [];
    for (const runId of runIds) {
        const errorFile = path.join(batchDir, `${runId}-error.log`);
        const finalFile = path.join(batchDir, `${runId}-final.log`);
        
        if (await fs.pathExists(errorFile)) {
            const errors = await fs.readFile(errorFile, 'utf8');
            if (errors.trim()) {
                failedRuns.push({ runId, type: 'error', details: errors });
            }
        }
        
        if (await fs.pathExists(finalFile)) {
            const final = await fs.readFile(finalFile, 'utf8');
            if (final.includes('"success":false')) {
                failedRuns.push({ runId, type: 'final', details: final });
            }
        }
    }
    
    if (failedRuns.length > 0) {
        console.log(chalk.red(`\n❌ Failed runs: ${failedRuns.length}`));
        failedRuns.forEach(({ runId, type, details }) => {
            console.log(chalk.red(`  - ${runId} (${type})`));
            const lines = details.split('\n').filter(l => l.trim());
            if (lines.length > 0) {
                console.log(chalk.dim(`    ${lines[lines.length - 1]}`));
            }
        });
    }
    
    // Performance analysis
    console.log(chalk.green('\n⚡ Performance Analysis:'));
    const durations = [];
    for (const runId of runIds) {
        const startFile = path.join(batchDir, `${runId}-start.log`);
        const exitFile = path.join(batchDir, `${runId}-exit.log`);
        
        if (await fs.pathExists(startFile) && await fs.pathExists(exitFile)) {
            try {
                const startContent = await fs.readFile(startFile, 'utf8');
                const exitContent = await fs.readFile(exitFile, 'utf8');
                
                const startTime = new Date(startContent.match(/\[(.*?)\]/)?.[1] || 0);
                const exitTime = new Date(exitContent.match(/\[(.*?)\]/)?.[1] || 0);
                
                if (startTime && exitTime) {
                    const duration = exitTime - startTime;
                    durations.push({ runId, duration });
                }
            } catch (err) {
                // Skip if timestamps can't be parsed
            }
        }
    }
    
    if (durations.length > 0) {
        const avgDuration = durations.reduce((sum, d) => sum + d.duration, 0) / durations.length;
        const maxDuration = Math.max(...durations.map(d => d.duration));
        const minDuration = Math.min(...durations.map(d => d.duration));
        
        console.log(chalk.dim(`  Average run time: ${(avgDuration / 1000).toFixed(1)}s`));
        console.log(chalk.dim(`  Fastest run: ${(minDuration / 1000).toFixed(1)}s`));
        console.log(chalk.dim(`  Slowest run: ${(maxDuration / 1000).toFixed(1)}s`));
    }
    
    // Common issues analysis
    console.log(chalk.green('\n🔍 Common Issues:'));
    const issuePatterns = [
        { pattern: /timeout/i, name: 'Timeouts' },
        { pattern: /captcha/i, name: 'CAPTCHA detected' },
        { pattern: /proxy.*error|connection.*failed/i, name: 'Proxy issues' },
        { pattern: /automation.*failed|autofill.*error/i, name: 'Automation failures' },
        { pattern: /extension.*error|chrome.*error/i, name: 'Browser/Extension errors' }
    ];
    
    for (const { pattern, name } of issuePatterns) {
        let count = 0;
        for (const runId of runIds) {
            for (const logType of ['stdout', 'stderr', 'error']) {
                const logFile = path.join(batchDir, `${runId}-${logType}.log`);
                if (await fs.pathExists(logFile)) {
                    const content = await fs.readFile(logFile, 'utf8');
                    if (pattern.test(content)) {
                        count++;
                        break; // Count once per run
                    }
                }
            }
        }
        if (count > 0) {
            console.log(chalk.yellow(`  - ${name}: ${count} runs affected`));
        }
    }
    
    console.log(chalk.green('\n💡 Troubleshooting Commands:'));
    console.log(chalk.dim(`  View all errors: cat ${batchDir}/*-error.log`));
    console.log(chalk.dim(`  View all stderr: cat ${batchDir}/*-stderr.log`));
    console.log(chalk.dim(`  View specific run: cat ${batchDir}/<runId>-*.log`));
    console.log(chalk.dim(`  Search for pattern: grep -i "error" ${batchDir}/*.log`));
}

async function main() {
    const args = process.argv.slice(2);
    
    if (args.length === 0) {
        console.log(chalk.blue('📊 Available batch logs:'));
        const batches = await findBatchDirs();
        if (batches.length === 0) {
            console.log(chalk.yellow('No batch logs found. Run a batch operation first.'));
            return;
        }
        batches.forEach(batch => {
            console.log(chalk.green(`  - ${batch}`));
        });
        console.log(chalk.dim('\nUsage: node analyze-batch-logs.js <batchId>'));
        return;
    }
    
    const batchId = args[0];
    await analyzeBatch(batchId);
}

main().catch(err => {
    console.error(chalk.red('Error analyzing logs:'), err.message);
    process.exit(1);
});